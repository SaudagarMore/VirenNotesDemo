üìÖ Day 1: The Basics ‚Äî What is Docker? üì¶The main idea of Docker is to solve the problem of "it works on my machine, but not in production."1. What is a Container? üñºÔ∏èA container is a small, portable package that holds everything your application needs to run: the code, runtime, libraries, settings, and dependencies.Simple Analogy: Think of a container as a shipping container for software. It doesn't matter if it's shipped by a train, truck, or boat (your development laptop, a cloud server, or a production machine); the contents inside are always guaranteed to run exactly the same way.Key Advantage: Unlike a Virtual Machine (VM), which has to run an entire separate Operating System (OS), a Docker container shares the host machine's OS kernel. This makes containers extremely lightweight and fast to start.2. Images vs. ContainersImage: A Docker Image is the blueprint or a read-only template used to create a container. It's built from instructions in a file (the Dockerfile, covered tomorrow).Analogy: The recipe or the class definition.Container: A running instance of an image.Analogy: The baked cake or the object created from the class.3. Basic Commandsdocker pull <image-name>: Downloads an image from a central registry (like Docker Hub).docker run <image-name>: Creates and starts a container from an image.Example: docker run -d -p 80:80 nginx-d: Run in detached mode (background).-p 80:80: Publish port 80 from the container to port 80 on your host machine.docker ps: Lists running containers.docker stop <container-id>: Gracefully stops a running container.üìÖ Day 2: Building Your Own Images (Dockerfile) üèóÔ∏èTo containerize your own application, you need a Dockerfile.1. What is a Dockerfile?A Dockerfile is a simple text file that contains a set of instructions used by the Docker engine to automatically build a new image. Each instruction in the file creates a read-only layer in the final image.2. Essential Dockerfile InstructionsInstructionPurposeSimple ExampleFROMSpecifies the base image (starting point).FROM node:18-alpineWORKDIRSets the current working directory inside the container.WORKDIR /appCOPYCopies files from your local machine into the image.COPY package.json .RUNExecutes a command during the image build (e.g., install dependencies).RUN npm installEXPOSEDocuments which port the application inside the container is listening on.EXPOSE 3000CMDDefines the default command to run when the container starts.CMD ["npm", "start"]3. The Build ProcessYou create a Dockerfile in your project folder.You run the build command: docker build -t my-app:v1 .-t my-app:v1: Tags the image with a name (my-app) and version (v1)..: Specifies the build context (the location of the Dockerfile).Docker executes the instructions, creates the layers, and results in your new custom image.üìÖ Day 3: Data and Communication (Volumes & Networking) üíæContainers are designed to be temporary, so you need ways to handle data and communication between them.1. Data Persistence (Volumes)By default, any data written inside a container is lost when the container is stopped and removed. Volumes fix this by storing data outside the container's writable layer.Volumes: These are Docker-managed storage areas on the host machine. They are the recommended way to persist data for databases or production applications. They don't disappear when the container is removed.Command Example: docker volume create my-dataRun Example: docker run -v my-data:/app/data my-appBind Mounts: These map a specific directory on your host file system directly into the container. Great for development because code changes on your host are instantly reflected in the running container.2. Container NetworkingWhen you run multiple containers that need to talk to each other (e.g., a web server container and a database container), you need a user-defined network.Default Network: Containers use a default bridge network, but they can't talk to each other by name.User-Defined Network:Create the network: docker network create my-networkRun containers connected to it: docker run --network my-network --name web-app my-web-app-imageContainers on the same user-defined network can talk to each other using their container names as the hostname (e.g., the web-app can connect to the database simply by calling the hostname db-server).üìÖ Day 4: Multi-Container Apps (Docker Compose) üåêManaging multiple containers, volumes, and networks manually with the docker CLI gets complicated fast. Docker Compose simplifies this.1. What is Docker Compose?Docker Compose is a tool for defining and running multi-container Docker applications. You define the entire application stack in a single file called docker-compose.yml (or compose.yaml).2. The docker-compose.yml FileThis YAML file defines your services (your containers), their configuration (ports, volumes, environment variables), and their dependencies.YAMLversion: '3.8'
services:
  # Service 1: The Web Application
  web:
    build: . # Build from the Dockerfile in the current directory
    ports:
      - "80:3000" # Map host port 80 to container port 3000
    depends_on:
      - db # Ensure 'db' starts before 'web'
  # Service 2: The Database
  db:
    image: postgres:latest # Use a pre-built image from Docker Hub
    environment:
      POSTGRES_PASSWORD: mysecretpassword
    volumes:
      - db_data:/var/lib/postgresql/data # Use a named volume for persistence

volumes:
  db_data: # Define the named volume
3. Essential Compose Commandsdocker compose up -d: Reads the compose.yaml file, builds images (if necessary), creates networks, and starts all services in detached mode.docker compose down: Stops and removes all containers, networks, and (optionally) volumes defined in the file.docker compose logs: Shows the combined logs from all running services.üìÖ Day 5: Scaling and Orchestration (Advanced) üöÄOnce your application is running perfectly with Compose, the next step is handling high traffic and scaling it across multiple machines‚Äîthis is orchestration.1. Container OrchestrationOrchestration tools manage the entire lifecycle of containers across a cluster of servers, providing:Scaling: Automatically running multiple copies (replicas) of a service.Load Balancing: Distributing traffic among those replicas.Self-Healing: Automatically replacing containers that fail.2. Key OrchestratorsOrchestratorBest ForComplexityKey FeatureDocker SwarmSmall to medium applications, easy setup, teams new to orchestration.LowSimple integration with the existing Docker CLI.Kubernetes (K8s)Large-scale, complex, and enterprise-level applications.HighThe industry standard for massive scale and rich features.3. Image Best Practices (The Advanced Build)Multi-Stage Builds: A key advanced technique in your Dockerfile. You use one stage to build your application (which pulls in all build tools and dependencies) and a final, lean stage that only copies the resulting production files. This drastically reduces the size and security attack surface of your final image..dockerignore: A file (like .gitignore) that tells the Docker builder which local files/folders (e.g., logs, temporary files) to ignore during the build process, resulting in faster and cleaner builds.